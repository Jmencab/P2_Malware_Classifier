from pprint import pprint
from collections import Counter
from tqdm import tqdm
import os
import util
import pandas as pd
import numpy as np
from sklearn.naive_bayes import BernoulliNB as bnb
try:
    import xml.etree.cElementTree as ET
except ImportError:
    import xml.etree.ElementTree as ET

#################################
###########Ideas#################
###########TODO##################
#1 Implement Bayesian  Model Selection
#2 Implement binomial array for n features

'''
Uses extract_features as blueprint for extracting list of trees
Also returns list of classes and ids
'''
def extract_tree(direc="train"):
    classes = []
    ids = []
    tree_list = [] 
    for datafile in os.listdir(direc):
        # extract id and true class (if available) from filename
        id_str,clazz = datafile.split('.')[:2]
        ids.append(id_str)
        # add target class if this is training data
        try:
            classes.append(util.malware_classes.index(clazz))
        except ValueError:
            # we should only fail to find the label in our list of malware classes
            # if this is test data, which always has an "X" label
            assert clazz == "X"
            classes.append(-1)
        tree_list.append(ET.parse(os.path.join(direc,datafile)))

    return tree_list, classes, ids

def system_call_count_feats(tree):

	c = Counter()
	in_all_section = False
	for el in tqdm(tree.iter()):
	    # ignore everything outside the "all_section" element
	    if el.tag == "all_section" and not in_all_section:
	        in_all_section = True
	    elif el.tag == "all_section" and in_all_section:
	        in_all_section = False
	    elif in_all_section:
	        c['num_system_calls'] += 1
	return c

def newFile(tree_list, classes, ids, writefile):
    f = open(writefile, "w+")
    f.write("Id,Class,f0,f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f11,f12,f13,f14,f15,f16,f17,f18,f19\n")
    index = 0
    for tree in tree_list:
        count = bin(system_call_count_feats(tree)['num_system_calls']).lstrip('0b')
        binStr = ''
        pad_zeros = 20-len(count)
        for _ in range(pad_zeros):
            binStr += "0,"
        for num in count:
            binStr += (num + ',')
        binStr = binStr.rstrip(',')
        f.write(ids[index] + "," + str(classes[index]) + "," + binStr + "\n")
        index +=1
    f.close()

def main():
    priors = [.0369,.0162,.012,.0103,.0133,.0126,.0172,.0133,.5214,.0068,.1756,.0104,.1218,.0191,.013]

    # train_tree_list, train_classes, train_ids = extract_tree("train")
    # newFile(train_tree_list, train_classes, train_ids, "choppyTrain.csv")
    # del train_tree_list,train_classes,train_ids
    test_tree_list, test_classes, test_ids = extract_tree("test")
    # newFile(test_tree_list, test_classes, test_ids, "choppyTest.csv")
    del test_tree_list,test_classes
    """
    Read in train and test as Pandas DataFrames
    """
    df_train = pd.read_csv("choppyTrain.csv")
    df_test = pd.read_csv("choppyTest.csv")
    #store class values
    Y_train = df_train.Class.values
    #row where testing examples start
    test_idx = df_train.shape[0]
    df_all = pd.concat((df_train, df_test), axis=0)
    del df_train
    del df_test
    df_all = df_all.drop(['Id'], axis=1)
    df_all = df_all.drop(['Class'], axis=1)
    vals = df_all.values
    del df_all
    X_train = vals[:test_idx]
    X_test = vals[test_idx:]
    del vals
    clf = bnb(class_prior=priors)
    clf.fit(X_train, Y_train)
    del X_train
    del Y_train
    bnb_predict = clf.predict(X_test)
    util.write_predictions(bnb_predict,test_ids,"ChoppySingleBNB.csv")

if __name__ == "__main__":
    main()