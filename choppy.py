import classification_starter as cs
from pprint import pprint
from collections import Counter
from tqdm import tqdm
import os
import util
try:
    import xml.etree.cElementTree as ET
except ImportError:
    import xml.etree.ElementTree as ET

#################################
###########Ideas#################
###########TODO##################
#1 Implement Bayesian  Model Selection
#2 Implement binomial array for n features

'''
Uses extract_features as blueprint for extracting list of trees
Also returns list of classes and ids
'''
def extract_tree(direc="train", global_feat_dict=None):
    classes = []
    ids = []
    tree_list = [] 
    for datafile in os.listdir(direc):
        # extract id and true class (if available) from filename
        id_str,clazz = datafile.split('.')[:2]
        ids.append(id_str)
        # add target class if this is training data
        try:
            classes.append(util.malware_classes.index(clazz))
        except ValueError:
            # we should only fail to find the label in our list of malware classes
            # if this is test data, which always has an "X" label
            assert clazz == "X"
            classes.append(-1)
        tree_list.append(ET.parse(os.path.join(direc,datafile)))

    return tree_list, classes, ids

def system_call_count_feats(tree):

	c = Counter()
	in_all_section = False
	for el in tqdm(tree.iter()):
	    # ignore everything outside the "all_section" element
	    if el.tag == "all_section" and not in_all_section:
	        in_all_section = True
	    elif el.tag == "all_section" and in_all_section:
	        in_all_section = False
	    elif in_all_section:
	        c['num_system_calls'] += 1
	return c
def main():
    train_dir = "train"
    test_dir = "test"
    tree_list, classes, ids = extract_tree()
    f = open("choppy.csv", "w+")
    f.write("Id,Class,Count_as_Bits\n")
    index = 0
    for tree in tree_list:
    	count = bin(system_call_count_feats(tree)['num_system_calls']).lstrip('0b')
        binStr = ''
        pad_zeros = 17-len(count)
        for _ in range(pad_zeros):
            binStr += "0,"
        for num in count:
            binStr += (num + ',')
        binStr = binStr.rstrip(',')
        f.write(ids[index] + "," + str(classes[index]) + "," + binStr + "\n")
        index +=1
    f.close()



    # ffs = [system_call_count_feats]
    # # extract features
    # print "extracting training features..."
    # X_train,global_feat_dict,t_train,train_ids = cs.extract_feats(ffs, train_dir)
    # # print "X_train:"
    # # pp.pprint(X_train)
    # print "global_feat_dict"
    # pp.pprint(global_feat_dict)
    # # print "t_train"
    # # pp.pprint(t_train)
    # # print "train_ids"
    # # pp.pprint(train_ids)
    # print "done extracting training features"
    # print

if __name__ == "__main__":
    main()